#!/bin/bash

#! This file was automatically generated by build script. Do not modify! ##

#! AirShell - Airline inspired Bash prompt
#! Copyright 2015 Robert Pasi≈Ñski
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# GitHub repository:
#   https://github.com/robik/airshell


# If not interactive, skip
[[ -z "$PS1" && -z "$AIRSH_DEBUG" ]] && return


#--- BEGIN 'source/airsh/state.sh' ---
## Path to airshell.sh
AIRSH_PATH=`readlink -f "$0"`

## Directory containing airshell.sh
AIRSH_ROOT_DIR=`dirname "$AIRSH_PATH"`

## Directory in which modules and themes are installed
AIRSH_INSTALL_DIR="${AIRSH_INSTALL_DIR-"$AIRSH_ROOT_DIR"}"

## Path to directory with themes
AIRSH_THEMES_DIR="${AIRSH_THEMES_DIR-"$AIRSH_ROOT_DIR/themes"}"

## Path to directory with modules
AIRSH_MODULES_DIR="${AIRSH_MODULES_DIR-"$AIRSH_INSTALL_DIR/modules"}"

## .airshellrc file location
AIRSH_RCFILE="${AIRSH_RCFILE-"/home/$USER/.airshellrc.sh"}"

## Theme name
# Set with `use-theme` in rcfile
AIRSH_THEME="${AIRSH_THEME-"default"}"

## Modules for left and right parts
AIRSH_ROW_COUNT=0

# For each row following variables are added (starting from 0)
# AIRSH_ROW_#_LEFT=()
# AIRSH_ROW_#_RIGHT=()

## Modules rendered before input (at the same line)
AIRSH_PREFIX_COMPONENTS=()

# List of loaded modules
AIRSH_MODULES_LOADED=()

## List of registered components
AIRSH_COMPONENTS_LOADED=()

## List of components with passed init()
AIRSH_COMPONENTS_AVAILABLE=()

## List of components with update method
AIRSH_COMPONENTS_WITH_UPDATE=()

AIRSH_FAIL=1
AIRSH_OK=0
AIRSH_STATUS=0 # 0 for true
AIRSH_LAST_COMMAND_STATUS=0

AIRSH_CONF_NEWLINE=true
AIRSH_CONF_AUTO_START=true
AIRSH_CONF_THEME="default"

AIRSH_CONF_LEFT_DELIM="\ue0b0"
AIRSH_CONF_RIGHT_DELIM=""
#AIRSH_CONF_RIGHT_DELIM="\ue0b2"

AIRSH_ORIGINAL_PS1="$PS1"
#--- END 'source/airsh/state.sh' ---

#--- BEGIN 'source/airsh/ansi.sh' ---
### TERMINAL COLORS

AIRSH_ANSI_RESET='\e[0m'

AIRSH_FG_BLACK='\e[0;30m'
AIRSH_BG_BLACK='\e[40m'
AIRSH_FG_GREY='\e[1;30m'

AIRSH_FG_RED='\e[0;31m'
AIRSH_BG_RED='\e[41m'
AIRSH_FG_LIGHT_RED='\e[1;31m'

AIRSH_FG_GREEN='\e[0;32m'
AIRSH_BG_GREEN='\e[42m'
AIRSH_FG_LIGHT_GREEN='\e[1;32m'

AIRSH_FG_BROWN='\e[0;33m'
AIRSH_BG_BROWN='\e[43m'
AIRSH_FG_YELLOW='\e[1;33m'

AIRSH_FG_BLUE='\e[0;34m'
AIRSH_BG_BLUE='\e[44m'
AIRSH_FG_LIGHT_BLUE='\e[1;34m'

AIRSH_FG_PURPLE='\e[0;35m'
AIRSH_BG_PURPLE='\e[45m'
AIRSH_FG_LIGHT_PURPLE='\e[1;35m'

AIRSH_FG_CYAN='\e[0;36m'
AIRSH_BG_CYAN='\e[46m'
AIRSH_FG_LIGHT_CYAN='\e[1;36m'

AIRSH_FG_GREY='\e[0;37m'
AIRSH_BG_GREY='\e[47m'
AIRSH_FG_WHITE='\e[1;37m'

#--- END 'source/airsh/ansi.sh' ---

#--- BEGIN 'source/airsh/utils.sh' ---
## Prints formatted message with colors
#
# Arguments:
#  main_ansi    ANSI code for main color (can be fg or bg)
#  alt_ansi     ANSI code for alternate color (can be fg or bg)
#  prefix       Message prefixed with main color
#  text...      Message parts
#
# This function swaps `main_ansi` with `alt_ansi` for every parameter (not every word though).
# That is every second parameter after `prefix` will be styled with `main_ansi` and others with `alt_ansi`.
# There is no space between `text`s.
_airsh_formatted_msg() {
    local main_color="$1"; shift
    local alt_color="$1"; shift
    local prefix="${1^^}"; shift
    local msg

    printf "${main_color}$prefix${AIRSH_ANSI_RESET} "

    local i=0
    for msg in "$@"; do
        if (( i % 2 == 0 )); then
            printf "${main_color}"
        else
            printf "${alt_color}"
        fi
        printf "$msg${AIRSH_ANSI_RESET}"

        ((i+=1))
    done

    printf "\n"
}


## Prints formatted error message
#
# Arguments:
#  text...      Message parts
#
# This function swaps bold red with red for every parameter (not every word).
airsh_error() {
    AIRSH_STATUS=$AIRSH_FAIL

    _airsh_formatted_msg "$AIRSH_FG_LIGHT_RED\e[24m" "$AIRSH_FG_LIGHT_RED\e[4m" "Error" "$@"
}


## Prints formatted warning message
#
# Arguments:
#  text...      Message parts
#
# This function swaps bold red with red for every parameter (not every word).
airsh_warn() {
    _airsh_formatted_msg $AIRSH_FG_YELLOW $AIRSH_FG_BROWN "Warning" "$@"
}


airsh_assert_name() {
    local key="$1"; shift
    local res
    [[ ! "$key" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]]
    res=$?
    if [ $res -eq 0 ]; then
        airsh_warn "" "$key" " is not valid name"
    fi
    return $res
}


## Checks if function with specified name exists.
airsh_func_exists() {
    [ `type -t $1`"" == 'function' ]
}


airsh_func_get_source() {
    local name="$1"; shift

    echo "$(declare -f $name | tail -n +2)"
    #src=${src#*\{}
    #src=${src%\}}"$src"
}


## Checks if array contains an element.
airsh_array_has_element() {
    local element="$1"; shift
    local array="$@";

    case "$array" in
        *"$element"*)
            return 0
            ;;
        *)
            return 1
    esac
}
#--- END 'source/airsh/utils.sh' ---

#--- BEGIN 'source/airsh/module.sh' ---
airsh_module_load() {
    local name="$1"; shift
    local location="$AIRSH_MODULES_DIR/$name.sh"

    if airsh_module_is_loaded $name; then
        return
    fi

    if [ ! -f $location ]; then
        airsh_error "Module '" $name "' cannot be found (is it installed?): '" $location "'"
        return
    fi

    AIRSH_MODULES_LOADED+=("$name")

    airsh_module_dsl_install
    . $location
    if airsh_func_exists "airsh_mod_${name,,}__init"; then
        eval "airsh_mod_${name,,}__init"
    fi
    airsh_module_dsl_uninstall

    local res
    local component
    for component in `airsh_module_get_prop -a $name "exports"`; do
        if ! airsh_array_has_element $component ${AIRSH_COMPONENTS_AVAILABLE[@]}; then
            if airsh_func_exists "airsh_comp_${component}__init"; then
                eval "airsh_comp_${component}__init; res=$?"
                if [ $res -eq $AIRSH_OK ]; then
                    AIRSH_COMPONENTS_AVAILABLE+=("$component")
                fi
            else
                AIRSH_COMPONENTS_AVAILABLE+=("$component")
            fi
        fi
    done
}


airsh_module_is_loaded() {
    local name="$1"; shift

    airsh_array_has_element "$name" ${AIRSH_MODULES_LOADED[@]}
}


airsh_module_get_prop() {
    local array=false
    if [ "$1" = "-a" ]; then
        array=true
        shift
    fi

    local module=${1^^}; shift
    local name="${1^^}"; shift
    module=${module//-/_}
    name=${name//-/_}

    { airsh_assert_name $name; } && return
    if $array; then
        name="$name[@]"
    fi
    local var="AIRSH_MOD_${module}_${name}"
    echo "${!var}"
}


airsh_module_set_prop() {
    local module=${1^^}; shift
    local name="${1^^}"; shift
    local value="$1"; shift
    module=${module//-/_}
    name=${name//-/_}

    { airsh_assert_name $name; } && return
    eval "AIRSH_MOD_${module}_${name}=\"$value\""
}


airsh_module_get_conf() {
    local module=${1^^}; shift
    local name="${1^^}"; shift

    echo `airsh_module_get_prop "$module" "CONF_$name"`
}


airsh_module_set_conf() {
    local module=${1^^}; shift
    local name="${1^^}"; shift

    echo `airsh_module_set_prop "$module" "CONF_$name"`
}
#--- END 'source/airsh/module.sh' ---

#--- BEGIN 'source/airsh/component.sh' ---
airsh_component_is_available() {
    local name="$1"; shift

    airsh_array_has_element "$name" ${AIRSH_COMPONENTS_AVAILABLE[@]}
}


airsh_component_check() {
    local name="$1"; shift

    airsh_component_is_available $name
    if [ $? -ne $AIRSH_OK ] ; then
        airsh_error "Component " $name " is not available (are you sure you loaded the parent module?)"
        AIRSH_STATUS=$AIRSH_FAIL
    fi
}


airsh_component_get_module() {
    local module
    local component="$1"; shift

    for module in ${AIRSH_MODULES_LOADED[@]}; do
        local components="$(airsh_module_get_prop -a exports)"

        if airsh_array_has_element "$component" ${components[@]}; then
            echo "$module"
            return
        fi
    done

    return $AIRSH_FAIL
}


airsh_component_get_prop() {
    local component="${1^^}"; shift
    local key="${1^^}"; shift
    component=${component//-/_}
    key=${key//-/_}

    { airsh_assert_name $key; } && return
    local var="AIRSH_COMP_${component}_${key}"
    echo "${!var}"
}


airsh_component_set_prop() {
    local component="${1^^}"; shift
    local key="${1^^}"; shift
    local value="$1"; shift
    component=${component//-/_}
    key=${key//-/_}
    local target_var="AIRSH_COMP_${component}_${key}"

    { airsh_assert_name $key; } && return
    if [ -z "$target_var" ]; then
        airsh_warn "Key $key does not exist ($target_var)"
        return
    fi

    eval "$target_var=\"$value\""
}


airsh_component_get_conf() {
    local component="$1"; shift
    local key="$1"; shift

    airsh_component_get_prop $component "conf_$key"
}


airsh_component_set_conf() {
    local component="$1"; shift
    local key="$1"; shift
    local value="$1"; shift

    airsh_component_set_prop $component "conf_$key" $value
}


airsh_component_return_text() {
    AIRSH_COMPONENT_RESULT="$1"; shift

    if [ $# -lt 1 ]; then
        AIRSH_COMPONENT_LENGTH="${#AIRSH_COMPONENT_RESULT}"
    else
        AIRSH_COMPONENT_LENGTH="$1"
    fi
}


airsh_component_return_none() {
    AIRSH_COMPONENT_RESULT=""
    AIRSH_COMPONENT_LENGTH="-1"
}
#--- END 'source/airsh/component.sh' ---

#--- BEGIN 'source/airsh/theme.sh' ---
airsh_theme_load() {
    local name="$1"; shift
    local location="$AIRSH_THEMES_DIR/$name.sh"

    if airsh_theme_is_loaded $name; then
        return
    fi

    if [ ! -f $location ]; then
        airsh_error "Theme '" $name "' cannot be found (is it installed?): '" $location "'"
        return
    fi

    name="${name//-/_}"
    AIRSH_THEMES_LOADED+=("$name")

    airsh_theme_dsl_install
    . $location
    if airsh_func_exists "airsh_theme_${name,,}__init"; then
        eval "airsh_theme_${name,,}__init"
    fi
    airsh_theme_dsl_uninstall
}

airsh_theme_is_loaded() {
    local name="$1"; shift

    airsh_array_has_element "$name" ${AIRSH_THEMES_LOADED[@]}
}


airsh_theme_get_var() {
    local array=false
    if [ "$1" = "-a" ]; then
        array=true
        shift
    fi

    local theme=${1^^}; shift
    local name="${1^^}"; shift
    theme=${theme//-/_}
    name=${name//-/_}

    { airsh_assert_name $name; } && return
    if $array; then
        name="$name[@]"
    fi

    echo "AIRSH_THEME_${theme}_${name}"
}

airsh_theme_get_prop() {
    local var="$(airsh_theme_get_var $@)"
    echo "${!var}"
}


airsh_theme_set_prop() {
    local var="$(airsh_theme_get_var $@)"
    eval "$var=\"$3\""
}

airsh_theme_set_style() {
    local var="$(airsh_theme_get_var $@)"
    eval "$var=\"$3\""
}


airsh_theme_get_conf() {
    local theme=${1^^}; shift
    local name="${1^^}"; shift

    echo `airsh_module_get_prop "$theme" "CONF_$name"`
}


airsh_theme_set_conf() {
    local theme=${1^^}; shift
    local name="${1^^}"; shift
    local value="${1}"; shift

    echo `airsh_module_set_prop "$theme" "CONF_$name" "$value"`
}

airsh_current_theme_get_prop() {
    if [ "$1" = "-a" ]; then
        shift
        airsh_theme_get_prop -a $AIRSH_CONF_THEME $@
    else
        airsh_theme_get_prop $AIRSH_CONF_THEME $@
    fi
}


airsh_current_theme_get_style() {
    local row_i=$1; shift
    local name="$1"; shift

    local style="$(airsh_current_theme_get_prop style_$name)"
    local default_bg="$(airsh_current_theme_get_prop row_{$row_id}_bg)"
    echo "${style//DEFAULT_BG/$default_bg}"
}
#--- END 'source/airsh/theme.sh' ---

#--- BEGIN 'source/airsh/render.sh' ---
airsh_render_fill_row() {
    local bg_color="$1"; shift
    local cols=$(tput cols)

    printf "\e[48;5;${bg_color}m%${cols}s\e[399D"
}


airsh_render_row_left() {
    local wrap_start=""
    local wrap_end=""

    if [ "$1" = "-p" ]; then
        wrap_start="\x01" # work exactly as \[ and \]
        wrap_end="\x02"
        shift
    fi

    local row_i=$1; shift

    local components=()
    local components_len=$#
    local components_i=0
    local result_var
    local comp_styles=()
    local comp_bgs=()
    local row_styles=($(airsh_current_theme_get_prop -a row_${row_i}_styles))
    local i=0 # keeps original index before filtering

    if [ ${#row_styles[@]} -eq 0 ]; then
        row_styles=($(airsh_current_theme_get_prop -a styles))
    fi

    # Evaluate components
    for component in $@; do
        eval "airsh_comp_${component}"
        if [ "$AIRSH_COMPONENT_LENGTH" = "-1" ]; then
            ((i+=1))
             continue
         fi
        components+=("$component")
        eval "local comp_result_$components_i=\"$AIRSH_COMPONENT_RESULT\""

        # if override exists
        local style_name="$(airsh_component_get_prop $component style)"
        if [ "$style_name" = "" ]; then
            style_name="${row_styles[$(($i % ${#row_styles}))]}"
        fi
        comp_styles+=("$(airsh_current_theme_get_style $row_i $style_name)")
        local style_bg="$(airsh_current_theme_get_prop style_${style_name}_bg)"
        comp_bgs+=("${style_bg:-$(airsh_current_theme_get_prop row_${row_i}_bg)}")

        ((i+=1))
        ((components_i+=1))
    done

    # -p is passed on prefix line and we leave here last delimeter bg default rather than row color
    if [ -z "$wrap_start" ]; then
        comp_bgs+=("$(airsh_current_theme_get_prop row_${row_i}_bg)")
    fi

    components_len=$components_i
    components_i=0

    # Display filtered components
    for component in ${components[@]}; do
        result_var="comp_result_$components_i"

        printf "$wrap_start%s$wrap_end ${!result_var} $wrap_start\e[0m$wrap_end" "${comp_styles[$components_i]}"

        if [ $components_i -lt `expr $components_len` ]; then
            local next_i=`expr $components_i + 1`
            #echo "i: $components_i, next: $next_i, nextc: $next_component"
            printf "$wrap_start\e[38;5;%s;48;5;%sm$wrap_end$AIRSH_CONF_LEFT_DELIM" "${comp_bgs[$components_i]}" "${comp_bgs[$next_i]}"
        fi

        ((components_i+=1))
    done
}


airsh_render_row_right() {
    # Goto end of the line
    printf "\e[499C"

    local row_i=$1; shift
    local components=()
    local components_len=$#
    local components_i=0
    local result_var
    local length_var
    local comp_styles=()
    local comp_bgs=()
    local row_styles=($(airsh_current_theme_get_prop -a row_${row_i}_styles))
    local i=0 # keeps original index before filtering

    if [ ${#row_styles[@]} -eq 0 ]; then
        row_styles=($(airsh_current_theme_get_prop -a styles))
    fi

    # Evaluate components to skip hidden
    for component in $@; do
        eval "airsh_comp_${component}"
        [ "$AIRSH_COMPONENT_LENGTH" = "-1" ] && continue
        components+=("$component")
        eval "local comp_result_$components_i=\"$AIRSH_COMPONENT_RESULT\""
        eval "local comp_length_$components_i=\"$AIRSH_COMPONENT_LENGTH\""

        # if override exists
        local style_name="$(airsh_component_get_prop $component style)"
        if [ "$style_name" = "" ]; then
            style_name="${row_styles[$(($i % ${#row_styles}))]}"
        fi
        comp_styles+=("$(airsh_current_theme_get_style $row_i $style_name)")
        local style_bg="$(airsh_current_theme_get_prop style_${style_name}_bg)"
        comp_bgs+=("${style_bg:-$(airsh_current_theme_get_prop row_${row_i}_bg)}")

        ((i+=1))
        ((components_i+=1))
    done

    comp_bgs+=("$(airsh_current_theme_get_prop row_${row_i}_bg)")
    components_len=$components_i
    components_i=0

    # Display filtered components
    for component in ${components[@]}; do
        result_var="comp_result_$components_i"
        length_var="comp_length_$components_i"

        local component_length=${!length_var}

        # Move cursor back and draw delimeter
        if [ "$AIRSH_CONF_RIGHT_DELIM" != "" ]; then
            ((component_length+=2))
            printf "\e[${component_length}D"
            printf "\e[38;5;%s;48;5;%sm$AIRSH_CONF_RIGHT_DELIM" "${comp_bgs[$components_i]}" "${comp_bgs[$(($components_i + 1))]}"
        else
            ((component_length+=1))
            printf "\e[${component_length}D"
        fi

        printf "%s ${!result_var} \e[0m" "${comp_styles[$components_i]}"

        ((component_length+=2))
        printf "\e[${component_length}D"
        ((components_i+=1))
    done

    printf "\e[299C\e[0m\n"
}

airsh_render_rows() {
    local i=0
    while [ $i -lt $AIRSH_ROW_COUNT ]; do
        airsh_render_fill_row $(airsh_current_theme_get_prop row_${i}_bg)

        local left_var="AIRSH_ROW_${i}_LEFT"
        local right_var="AIRSH_ROW_${i}_RIGHT"

        # Build list of non-empty modules
        airsh_render_row_left $i ${!left_var}
        airsh_render_row_right $i ${!right_var}
        ((i+=1))
    done
}


airsh_render_prefix() {
    local last_index=`expr ${#AIRSH_PREFIX_COMPONENTS[@]} - 1`
    local last_component="${AIRSH_PREFIX_COMPONENTS[$last_index]}"
    airsh_render_row_left -p 0 ${AIRSH_PREFIX_COMPONENTS[@]}
}


airsh_render_ps1() {
    printf "\[$AIRSH_ANSI_RESET\]"
    if $AIRSH_CONF_NEWLINE; then
        echo
    fi

    echo "\[\$(airsh_render_rows)\]"
    if [ ${#AIRSH_PREFIX_COMPONENTS[@]} -gt 0 ]; then
        printf "\$(airsh_render_prefix)"
    fi
    printf "\[$AIRSH_ANSI_RESET\] "
}
#--- END 'source/airsh/render.sh' ---

#--- BEGIN 'source/api/user.sh' ---
airshell-set() {
    local reload=true

    # no reload
    if [ "$1" == "-n" ]; then
        reload=false
        shift
    fi

    local name="${1}"; shift
    local value="$1"; shift
    local var="AIRSH_CONF_${name^^}"
    var=${var//-/_}
    local value="${!var}"

    if [ -z ${value+t} ]; then
        airsh_error "Configuration variable " $name " does not exist ($var)"
        return
    fi

    eval "$var=$value"
    $reload && airshell-enable
}


airshell-disable() {
    PS1="$AIRSH_ORIGINAL_PS1"
}


airshell-enable() {
    PS1="$(airsh_render_ps1)"
}


airshell-reload() {
    airsh_rc_dsl_install
    if [ -f "$AIRSH_RCFILE" ]; then
        source "$AIRSH_RCFILE"
    fi
    airsh_rc_dsl_uninstall
}


airshell-configure() {
    editor $AIRSH_RCFILE
}


airshell-component-set() {
    local component="$1"; shift
    local key="$1"; shift
    local value="$1"; shift

    airsh_component_set_conf $component $key $value
    airshell-enable
}
#--- END 'source/api/user.sh' ---

#--- BEGIN 'source/api/rcfile.sh' ---
airsh_rc_load_theme() {
    local theme="$1"; shift

    airsh_theme_load $theme
}

airsh_rc_load_modules() {
    local module

    for module in $@; do
        airsh_module_load $module
    done
}


airsh_rc_load_all_modules() {
    for filename in $AIRSH_MODULES_DIR/*.sh; do
        airsh_rc_load_modules `basename "${filename%%.*}"`
    done
}


airsh_rc_prefix() {
    local component
    [ "$1" == "[" ] && shift

    for component in $@; do
        component=${component//-/_}
        [ "$component" == "]" ] && break
        airsh_component_check $component
        AIRSH_PREFIX_COMPONENTS+=("$component")
    done
}


airsh_rc_row() {
    eval "AIRSH_ROW_${AIRSH_ROW_COUNT}_LEFT=()"
    eval "AIRSH_ROW_${AIRSH_ROW_COUNT}_RIGHT=()"

    if [ "$1" != "[" ]; then
        airsh_error "row must start with ["
        return
    fi
    shift
    local component

    while [ $# -gt 0 ]; do
        component="${1//-/_}"; shift

        [ "$component" == "]" ] && break
        airsh_component_check "$component"
        eval "AIRSH_ROW_${AIRSH_ROW_COUNT}_LEFT+=\"$component \""
    done

    if [ $# -lt 1 ]; then
        AIRSH_ROW_COUNT=`expr $AIRSH_ROW_COUNT + 1`
        return
    fi

    if [ "$1" == "[" ]; then
        shift
        while [ $# -gt 0 ]; do
            component="${1//-/_}"; shift

            [ "$component" == "]" ] && break
            airsh_component_check "$component"
            eval "AIRSH_ROW_${AIRSH_ROW_COUNT}_RIGHT=\"$component \$AIRSH_ROW_${AIRSH_ROW_COUNT}_RIGHT\""
        done
    else
        airsh_error "Expected [ in row statement"
    fi

    AIRSH_ROW_COUNT=`expr $AIRSH_ROW_COUNT + 1`
}


airsh_rc_set() {
    local name="$1"; shift
    local value="$1"; shift

    # Global set
    if [ -z "${AIRSH_DSL_CURR_COMP}" ]; then
        airshell-set -n $name "$value"
        return
    fi

    if [[ ! "$name" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
        airsh_warn "Property name '" $name "' is invalid"
        return
    fi

    local target_var="AIRSH_COMP_${AIRSH_DSL_CURR_COMP^^}_PROP_${name^^}"
    if [ -z "${!taret_var}" ]; then
        airsh_warn "Property name '" $name "' does not exist"
        return
    fi

    eval "$target_var=\"$value\""
}

airsh_rc_component_style() {
    local name="${1}"; shift
    local style="${1}"; shift

    airsh_component_set_prop $name style $style
}


airsh_rc_dsl_install() {
    alias load-all-modules=airsh_rc_load_all_modules
    alias load-module=airsh_rc_load_modules
    alias load-theme=airsh_rc_load_theme
    alias component-style=airsh_rc_component_style
    alias prefix=airsh_rc_prefix
    alias row=airsh_rc_row
    alias set=airsh_rc_set
}


airsh_rc_dsl_uninstall() {
    unalias load-all-modules load-module load-theme component-style prefix row set
}
#--- END 'source/api/rcfile.sh' ---

#--- BEGIN 'source/api/module.sh' ---
airsh_module_dsl_start_module() {
    local name="${1//-/_}"; shift

    AIRSH_MODULE_DSL_MODULE="$name"
    eval "AIRSH_MOD_${AIRSH_MODULE_DSL_MODULE^^}_EXPORTS=()"
}


_airsh_module_dsl_apply_component() {
    airsh_func_exists execute
    if [ $? -ne $AIRSH_OK ]; then
        airsh_error "" "execute" " function not defined in component " $AIRSH_MODULE_DSL_COMPONENT
        unset AIRSH_MODULE_DSL_COMPONENT
        return
    fi

    if airsh_func_exists init; then
        local src=`airsh_func_get_source init`
        eval "airsh_comp_${AIRSH_MODULE_DSL_COMPONENT,,}__init() $src"
        unset init
    fi

    if airsh_func_exists update; then
        local src=`airsh_func_get_source update`
        eval "airsh_comp_${AIRSH_MODULE_DSL_COMPONENT,,}__update() $src"
        unset update
        AIRSH_COMPONENTS_WITH_UPDATE+=("${AIRSH_MODULE_DSL_COMPONENT,,}")
    fi

    if [ ! -z "$AIRSH_MODULE_DSL_MODULE" ]; then
        eval "AIRSH_MOD_${AIRSH_MODULE_DSL_MODULE^^}_EXPORTS+=(\"$AIRSH_MODULE_DSL_COMPONENT\")"
    fi

    AIRSH_COMPONENTS_LOADED+=("$AIRSH_MODULE_DSL_COMPONENT")
    local src=`airsh_func_get_source execute`
    eval "airsh_comp_${AIRSH_MODULE_DSL_COMPONENT,,}() $src"
    unset execute
}

airsh_module_dsl_end() {
    if [ ! -z "$AIRSH_MODULE_DSL_COMPONENT" ]; then
        _airsh_module_dsl_apply_component
        unset AIRSH_MODULE_DSL_COMPONENT
    elif [ ! -z "$AIRSH_MODULE_DSL_MODULE" ]; then
        unset AIRSH_MODULE_DSL_MODULE
    else
        airsh_error "Unmatched 'end'"
    fi
}


airsh_module_dsl_start_component() {
    local name="${1//-/_}"; shift

    AIRSH_MODULE_DSL_COMPONENT="$name"
}


airsh_module_dsl_set() {
    local name="${1}"; shift
    local value="$1"; shift
    local func_name="set"

    # for wrappers
    if [ $# -gt 0 ]; then
        func_name="$1"
    fi

    if [ ! -z "$AIRSH_MODULE_DSL_COMPONENT" ]; then
        airsh_component_set_prop $AIRSH_MODULE_DSL_COMPONENT $name $value
    elif [ ! -z "$AIRSH_MODULE_DSL_MODULE" ]; then
        airsh_module_set_prop $AIRSH_MODULE_DSL_MODULE $name $value
    else
        airsh_error "" "$func_name" " is neither in " module " or " component " scope"
    fi
}


airsh_module_dsl_config() {
    local name="$1"; shift
    local value="$1"; shift

    airsh_module_dsl_set "conf_$name" "$value" "config"
}


_airsh_module_dsl_guard_module() {
    local func_name="$1"; shift

    if [ -z "$AIRSH_MODULE_DSL_MODULE" ]; then
        airsh_error "Using '" $func_name "' not in module definiton scope"
    fi
}


airsh_module_dsl_install() {
    alias prop=airsh_module_dsl_set
    alias module=airsh_module_dsl_start_module
    alias config=airsh_module_dsl_config
    alias end=airsh_module_dsl_end
    alias component=airsh_module_dsl_start_component
}


airsh_module_dsl_uninstall() {
    unalias prop module config end component
}
#--- END 'source/api/module.sh' ---

#--- BEGIN 'source/api/theme.sh' ---
airsh_theme_dsl_start() {
    local name="${1//-/_}"; shift

    AIRSH_THEME_DSL_ROW_INDEX=0
    AIRSH_THEME_DSL_NAME="$name"
}

airsh_theme_dsl_component_style() {
    _airsh_theme_dsl_guard "component-style"

    local name="${1}"; shift
    local style="${1}"; shift

    airsh_component_set_prop $name style $style
}

airsh_theme_dsl_row_order() {
    _airsh_theme_dsl_guard "row-order"

    local row_i=$1; shift
    local styles="$@";

    airsh_theme_set_prop $AIRSH_THEME_DSL_NAME row_${row_i}_styles "$styles"
}


airsh_theme_dsl_end() {
    _airsh_theme_dsl_guard "end"

    if airsh_func_exists init; then
        local src=`airsh_func_get_source init`
        eval "airsh_theme_${AIRSH_THEME_DSL_NAME,,}__init() $src"
        unset init
    fi

    unset AIRSH_THEME_DSL_ROW_INDEX
    unset AIRSH_THEME_DSL_NAME
}


airsh_theme_dsl_set() {
    _airsh_theme_dsl_guard "prop"

    local name="${1^^}"; shift
    local value="$1"; shift

    airsh_theme_set_prop $AIRSH_THEME_DSL_NAME $name "$value"
}

airsh_theme_dsl_row() {
    _airsh_theme_dsl_guard "row"
    local colors=($1); shift

    airsh_theme_set_prop $AIRSH_THEME_DSL_NAME row_${AIRSH_THEME_DSL_ROW_INDEX}_fg "${colors[0]}"
    airsh_theme_set_prop $AIRSH_THEME_DSL_NAME row_${AIRSH_THEME_DSL_ROW_INDEX}_bg "${colors[1]}"
    ((AIRSH_THEME_DSL_ROW_INDEX+=1))
}


airsh_theme_dsl_style() {
    _airsh_theme_dsl_guard "add"

    local name="${1}"; shift
    local styles=($1); shift
    local styles_var="$(airsh_theme_get_var $AIRSH_THEME_DSL_NAME styles)"
    airsh_theme_set_prop $AIRSH_THEME_DSL_NAME style_${name}_bg "${styles[1]}"

    eval "$styles_var+=(\"$name\")"
    value="$(airsh_theme_dsl_parse_style ${styles[@]})"
    airsh_theme_set_prop $AIRSH_THEME_DSL_NAME style_$name "$value"
}


airsh_theme_dsl_config() {
    _airsh_theme_dsl_guard "config"

    local name="$1"; shift
    local value="$1"; shift

    airsh_theme_dsl_set "conf_$name" "$value"
}


airsh_theme_dsl_parse_style() {
    local fore=$1; shift
    local back=$1; shift
    local extra="$1"; shift
    local res=""
    local row_i=$(($AIRSH_THEME_DSL_ROW_INDEX-1))

    res="\e[38;5;${fore}"
    if [ "$back" != "" ]; then
        res+=";48;5;${back}"
    fi
    if [ "$extra" != "" ]; then
        res+=";$extra"
    fi
    res+="m"
    echo -e "$res"
}


_airsh_theme_dsl_guard() {
    local func_name="$1"; shift

    if [ -z "$AIRSH_THEME_DSL_NAME" ]; then
        airsh_error "Using '" $func_name "' not in theme definiton scope"
    fi
}


airsh_theme_dsl_install() {
    alias style=airsh_theme_dsl_style
    alias prop=airsh_theme_dsl_set
    alias row-style=airsh_theme_dsl_row
    alias row-order=airsh_theme_dsl_row_order
    alias end=airsh_theme_dsl_end
    alias theme=airsh_theme_dsl_start
    alias config=airsh_theme_dsl_config
    alias component-style=airsh_theme_dsl_component_style
}


airsh_theme_dsl_uninstall() {
    unalias style prop row-style row-order end theme config component-style
}
#--- END 'source/api/theme.sh' ---
airsh_theme_load "default"
airsh_module_load "core"

# Check for config file existence
airsh_rc_dsl_install
if [ -f "$AIRSH_RCFILE" ]; then
    source "$AIRSH_RCFILE"
fi
airsh_rc_dsl_uninstall

if [ $AIRSH_STATUS -eq $AIRSH_FAIL ] ; then
    return
fi

prompt_command() {
    AIRSH_LAST_COMMAND_STATUS=$?
    local component

    for component in ${AIRSH_COMPONENTS_WITH_UPDATE[@]}; do
        eval "airsh_comp_${component}__update"
    done
}
PROMPT_COMMAND=prompt_command

if $AIRSH_CONF_AUTO_START; then
    airshell-enable
fi